package chord.model;

import chord.Exceptions.NotInitializedException;
import chord.Exceptions.PredecessorException;
import chord.Exceptions.SuccessorListException;
import chord.Exceptions.TimerExpiredException;

import java.util.concurrent.ScheduledFuture;

public class Node {
    private NodeInfo nodeInfo;
    private String nodeidentifier;
    private FingerTable fingerTable;
    private SuccessorList successorList;
    private NodeInfo newPredecessor;
    private boolean initialized;
    private boolean alone;
    private boolean terminated;
    private NodeDispatcher dispatcher;
    private int fixFingerCounter;
    private NodeComparator comparator;
    private ScheduledFuture terminate;

    //this constructor is called when you CREATE and when you JOIN an existent Chord
    public Node(NodeInfo me) {
        this.nodeInfo = me;
        //I need to computer the identifier associated to this node, given the key
        this.nodeidentifier = me.getHash();
        this.fingerTable = new FingerTable(me.getHash());
        this.successorList = new SuccessorList(me.getHash());
        this.newPredecessor = null;
        this.initialized = false;
        this.terminated = false;
        this.dispatcher = new NodeDispatcher(this.getPort());
        this.fixFingerCounter = 0;
        this.comparator=new NodeComparator(me.getHash());
        this.alone = true;
    }

    //getters
    public int getPort() {
        return this.nodeInfo.getPort();
    }
    public NodeInfo getPredecessor()throws PredecessorException {
        if (this.newPredecessor == null){
            throw new PredecessorException();
        }
        return newPredecessor;
    }

    public boolean isAlone() {
        return alone;
    }

    public void setAlone(boolean alone) {
        this.alone = alone;
    }


    //this method is called from messageHandler
    public NodeDispatcher getDispatcher() {
        return dispatcher;
    }

    public void modifyPort(int port) {
        this.nodeInfo.setPort(port);
        NodeInfo me = this.nodeInfo;
        String key = me.getIPAddress().concat(Integer.toString(me.getPort()));
        this.nodeidentifier = Utilities.hashfunction(key);
    }

    //periodic operations to handle changes in the chord
    public void stabilize() {
        try {
            NodeInfo newPredecessor = this.successorList.getFirstElement();
            NodeInfo potentialSuccessor = this.dispatcher.sendPredecessorRequest(newPredecessor, this.nodeInfo);
            if(potentialSuccessor.getHash().equals(this.nodeidentifier)) {
                return;
            }
            String successorKey = newPredecessor.getHash();
            String potentialSuccessorKey = potentialSuccessor.getHash();
            if(comparator.compare(potentialSuccessorKey,successorKey)<0){
                System.out.println("I'm : " + this.nodeidentifier + "and I'm modifying the newPredecessor due to stabilize :" +potentialSuccessorKey);
                this.successorList.modifyEntry(0,potentialSuccessor);
            }
        } catch (TimerExpiredException e) {
            repopulateSuccessorList(1);
            //put code here
        }catch (PredecessorException e){
            System.out.println("My newPredecessor said me he does not have a newPredecessor: " + this.nodeidentifier);
        }
        try {
            NodeInfo newPredecessor = this.successorList.getFirstElement();
            this.dispatcher.sendNotify(newPredecessor, this.nodeInfo);
        } catch (TimerExpiredException e) {
            repopulateSuccessorList(1);
            //put code here
        }

    }

    public void fixFinger() {
        String hashedkey = Utilities.computefinger(this.nodeidentifier, fixFingerCounter);
        NodeInfo nodeInfo = findSuccessor(hashedkey);
        if (nodeInfo == null){
            System.out.println("troppo lento!");
        }
        this.fingerTable.modifyFinger(fixFingerCounter, nodeInfo);
        fixFingerCounter++;
        if (fixFingerCounter == Utilities.numberOfBit()){
            fixFingerCounter = 0;
        }
    }

    public void fixSuccessorList(){
        for (int i = 0; i<3; i++){
            NodeInfo newPredecessor = successorList.getElement(i);
            NodeInfo newPredecessor = null;
            try {
                newPredecessor = dispatcher.sendFirstSuccessorRequest(newPredecessor,nodeInfo);
                if (newPredecessor.getHash().equals(nodeidentifier)) {
                    while (i < 3) {
                        successorList.modifyEntry(i+1, this.nodeInfo);
                        i++;
                    }
                } else {
                    successorList.modifyEntry(i+1, newPredecessor);
                }
            } catch (TimerExpiredException e) {
                System.out.println("I'm " + this.nodeidentifier + " and I experienced an exception in the newPredecessor list, getting the element "+ i);
                repopulateSuccessorList(i+1);
                //put code here
            }

        }
    }

    public void checkPredecessor() {
        if (newPredecessor != null) {
            try {
                dispatcher.sendPing(this.newPredecessor, this.nodeInfo);
            } catch (TimerExpiredException e) {
                System.out.println("I'm "+ this.nodeidentifier+ " and I'm trying to ping my newPredecessor, but time expired");
                newPredecessor = null;
                //put code here
            }
        }
        return;
    }

    //ritorno il primo elemento della mia successorList
    public NodeInfo getFirstSuccessor(){
        return successorList.getFirstElement();
    }

    //[in a recursive manner]
    //ask this node to find the newPredecessor of id
    //param = an hashed identifier of the item I want to retrieve
    public NodeInfo findSuccessor(String key){
        NodeInfo newPredecessor=null;
        if(key.equals(this.nodeidentifier)){
            return this.nodeInfo;
        }
        //am I responsible for that key? If yes return myself
        FingerTableComparator comparator= new FingerTableComparator(this.nodeidentifier);
        if(newPredecessor!=null){
            String predecessorKey= newPredecessor.getHash();
            if((comparator.compare(this.nodeidentifier,key)>=0)&& (comparator.compare(predecessorKey,key)<0)){
                return this.nodeInfo;
            }
        }
        //Is anyone from the newPredecessor list responsable for that key?
        try {
            newPredecessor = successorList.closestSuccessor(key);
            return newPredecessor;
            } catch (SuccessorListException e) {
            //we do not return the closest newPredecessor
        }

        //look in the finger table
        try {
            NodeInfo closestPredecessor = fingerTable.closestPredecessor(key);
            newPredecessor = this.dispatcher.sendSuccessorRequest(closestPredecessor,key,this.nodeInfo);
        } catch (TimerExpiredException ex) {
            //put code here
        }

        return newPredecessor;

    }



    //when you create a new chord, you have to initialize all the stuff
    //this method is called when you create a new Chord
    public synchronized void initialize() {
        for (int i = 0; i < Utilities.numberOfBit(); i++) {
            fingerTable.addFinger( this.nodeInfo);
        }
        for (int i = 0; i < 4; i++) {
            successorList.addEntry(this.nodeInfo);
        }
        this.newPredecessor = this.nodeInfo;
        this.initialized = true;
        this.terminate  = Threads.executePeriodically(new Utilities(this));
        this.printStatus();
        this.printUtilities();

    }

    public synchronized void start(NodeInfo nodeInfo){
        if (alone){
            this.successorList.modifyEntry(0, nodeInfo);
            this.fingerTable.modifyFinger(0, nodeInfo);
            setAlone(false);
        }

    }

    public synchronized void initialize(final NodeInfo myfriend) throws NotInitializedException {
        try {
            NodeInfo newPredecessor = this.dispatcher.sendSuccessorRequest(myfriend, this.nodeidentifier, this.nodeInfo);
            this.successorList.addEntry(newPredecessor);
            this.fingerTable.addFinger( newPredecessor);
            this.newPredecessor=null;
        } catch (TimerExpiredException e) {
            throw new NotInitializedException("impossible to initialize this node");
        }

        //first, the newPredecessor list
        for (int i = 1; i < 4; i++) {
            NodeInfo newPredecessor = successorList.getLastElement();
            NodeInfo newPredecessor = null;
            try {
                newPredecessor = dispatcher.sendFirstSuccessorRequest(newPredecessor,nodeInfo);
                if (newPredecessor.getHash().equals(nodeidentifier)) {
                    while (i < 4) {
                        successorList.addEntry( nodeInfo);
                        i++;
                    }
                } else {
                    successorList.addEntry(newPredecessor);
                }
            } catch (TimerExpiredException e) {
                this.successorList.removeLast();
                i--;
            }

        }
        for(int i=1; i<Utilities.numberOfBit(); i++) {
            String hashedkey = Utilities.computefinger(nodeidentifier, i);
            NodeInfo finger = null;
            NodeInfo newPredecessor = successorList.getFirstElement();
            try {
                finger = dispatcher.sendSuccessorRequest(newPredecessor, hashedkey, nodeInfo);
                fingerTable.addFinger(finger);
            } catch (TimerExpiredException e) {
                repopulateSuccessorList(1);
            }
        }
        initialized = true;
        setAlone(false);
        this.printStatus();
        this.printUtilities();
        try{
            dispatcher.sendStartRequest(myfriend, this.nodeInfo);
        }catch (TimerExpiredException e){
            //put code here
        }
        this.terminate  = Threads.executePeriodically(new Utilities(this));

    }

    //quando ricevo la notify controllo il mio predecessore e in caso lo aggiorno
    public void notify(NodeInfo potential_predecessor) {
        if(potential_predecessor.equals(this.nodeInfo)){
            System.out.println("sto notificando me stesso e sono: "+this.nodeidentifier);
            return;
        }
        if (this.newPredecessor == null) {
            this.newPredecessor = potential_predecessor;
        } else {
            //ho le due chiavi
            String predecessor_key = this.newPredecessor.getHash();
            String potential_key = potential_predecessor.getHash();
            //se la chiave del potenziale successore � pi� piccola del successore e pi� grande del nodo, allora ho trovato un nuovo predecessore
            if(comparator.compare(predecessor_key,potential_key)<0){
                this.newPredecessor=potential_predecessor;
            }
        }
    }

    public boolean isInitialized() {
        return initialized;
    }

    public void terminate() {
        terminate.cancel(true);
    }

    public boolean isTerminated() {
        return terminated;
    }

    public void repopulateSuccessorList(int positionOfLastValidNode){
        boolean foundOne = false;
        for (int j=positionOfLastValidNode; j<4 && !foundOne; j++){
            NodeInfo validNode  = this.successorList.getElement(j);
            NodeInfo newPredecessor = null;
            try {
                newPredecessor = this.dispatcher.sendSuccessorRequest(validNode, this.nodeidentifier, this.nodeInfo);
                foundOne = true;
                this.successorList.modifyEntry(0, newPredecessor);
                this.fingerTable.modifyFinger(0, newPredecessor);
            } catch (TimerExpiredException e1) {
                //this node is not valid
            }
        }
        if (foundOne){
            fixSuccessorList();
        }
    }



    //useful for testing
    public void printStatus() {
        System.out.println("-------------------");
        System.out.println("It's me:  " + this.nodeidentifier + "!");
        if (newPredecessor != null){
            System.out.println("newPredecessor: " + newPredecessor.getHash());
        }
        else {
            System.out.println("Predecessor is null");
        }

        successorList.printTable();
        fingerTable.printTable();
        System.out.println("-------------------");
    }

    public void printUtilities(){
        System.out.println("FINGERS ->");
        for (int i=0; i< 16; i++){
            System.out.println("finger "+ i + ": " + Utilities.computefinger(nodeidentifier, i));
        }
    }

    public FingerTable getFingerTable() {
        return fingerTable;
    }

    public SuccessorList getSuccessorList() {
        return successorList;
    }

    public NodeInfo getNodeInfo() {
        return nodeInfo;
    }


    public void setNodeInfo(NodeInfo nodeInfo) {
        this.nodeInfo = nodeInfo;
    }

    public void setNodeidentifier(String nodeidentifier) {
        this.nodeidentifier = nodeidentifier;
    }

    public void setFingerTable(FingerTable fingerTable) {
        this.fingerTable = fingerTable;
    }

    public void setSuccessorList(SuccessorList successorList) {
        this.successorList = successorList;
    }

    public void setPredecessor(NodeInfo newPredecessor) {
        this.newPredecessor = newPredecessor;
    }

    public void setDispatcher(NodeDispatcher nodeDispatcher){
        this.dispatcher=nodeDispatcher;
    }





}

